// src/libserver.ts
import http from "node:http";

// src/Router.ts
var Router = class {
  routes;
  constructor() {
    this.routes = [];
  }
  addRouter(method, path2, middlewares) {
    const middleware = middlewares.pop();
    this.routes.push({ method, path: path2, middlewares, middleware });
  }
  findRoute(req) {
    const { method, url, params } = req;
    if (!url) return void 0;
    const route = this.routes.find((r) => {
      const pathRegex = new RegExp("^" + r.path.replace(/\/:([^\/]+)/g, "/([^/]+)") + "$");
      return method === r.method && pathRegex.test(url.split("?")[0]);
    });
    if (route) {
      const pathMatch = url.split("?")[0].match(new RegExp(route.path.replace(/\/:([^\/]+)/g, "/([^/]+)")));
      if (pathMatch) {
        const paramNames = (route.path.match(/\/:([^\/]+)/g) || []).map((p) => p.replace("/:", ""));
        req.params = req.params || {};
        paramNames.forEach((paramName, index) => {
          req.params[paramName] = pathMatch[index + 1];
        });
      }
    }
    return route;
  }
  // Métodos REST para adicionar rotas com diferentes métodos HTTP
  get(path2, ...middlewares) {
    this.addRouter("GET", path2, middlewares);
  }
  post(path2, ...middlewares) {
    this.addRouter("POST", path2, middlewares);
  }
  put(path2, ...middlewares) {
    this.addRouter("PUT", path2, middlewares);
  }
  patch(path2, ...middlewares) {
    this.addRouter("PATCH", path2, middlewares);
  }
  delete(path2, ...middlewares) {
    this.addRouter("DELETE", path2, middlewares);
  }
};
var Router_default = Router;

// src/RequestHandler.ts
var RequestHandler = class {
  middlewares;
  router;
  constructor(middlewares, router) {
    this.middlewares = middlewares;
    this.router = router;
  }
  async handleRequest(req, res) {
    req.params = {};
    req.query = this.parseQueryParams(req);
    let index = 0;
    const globalNext = () => {
      if (index < this.middlewares.length) {
        const middleware = this.middlewares[index];
        index++;
        middleware(req, res, globalNext);
      } else {
        this.processRoute(req, res);
      }
    };
    globalNext();
  }
  parseQueryParams(req) {
    const url = req.url ? new URL(req.url, `http://${req.headers.host}`) : new URL("", `http://${req.headers.host}`);
    return Object.fromEntries(url.searchParams.entries());
  }
  processRoute(req, res) {
    const route = this.router.findRoute(req);
    if (route) {
      let index = 0;
      const routeNext = (err) => {
        if (err) {
          res.statusCode = 500;
          const errorMessage = err instanceof Error ? err.message : "Unknown Error";
          res.end(`Internal Server Error: ${errorMessage}`);
          return;
        }
        if (index < route.middlewares.length) {
          const middleware = route.middlewares[index];
          index++;
          try {
            middleware(req, res, routeNext);
          } catch (error) {
            const errorMessage = error instanceof Error ? error.message : "Unknown Error";
            res.statusCode = 500;
            res.end(`Internal Server Error: ${errorMessage}`);
          }
        } else {
          if (route.middleware) {
            try {
              route.middleware(req, res, () => {
              });
            } catch (error) {
              const errorMessage = error instanceof Error ? error.message : "Unknown Error";
              res.statusCode = 500;
              res.end(`Internal Server Error: ${errorMessage}`);
            }
          } else {
            res.statusCode = 500;
            res.end("Internal Server Error: No controller provided");
          }
        }
      };
      routeNext();
    } else {
      res.statusCode = 404;
      res.end("Not Found");
    }
  }
};
var RequestHandler_default = RequestHandler;

// src/middlewares/json.ts
var jsonBodyParsin = async (req, res, next) => {
  if (req.method === "POST" || req.method === "PUT" || req.method === "PATCH") {
    if (req.headers["content-type"]?.startsWith("application/json")) {
      try {
        req.body = await new Promise((resolve, reject) => {
          let bodyString = "";
          req.on("data", (chunk) => {
            bodyString += chunk.toString();
          });
          req.on("end", () => {
            try {
              resolve(JSON.parse(bodyString));
            } catch (error) {
              reject(error);
            }
          });
          req.on("error", (err) => {
            reject(err);
          });
        });
      } catch (error) {
        if (error instanceof Error) {
          res.statusCode = 400;
          res.end(`Erro no parse do JSON: ${error.message}`);
        } else {
          res.statusCode = 400;
          res.end("Erro desconhecido no parse do JSON");
        }
        return;
      }
    }
  }
  next();
};
var json_default = jsonBodyParsin;

// src/middlewares/upload.ts
import fs from "fs";
import path from "path";
var uploadMiddleware = (options) => {
  const uploadDir = path.resolve(options.path);
  if (!fs.existsSync(uploadDir)) {
    fs.mkdirSync(uploadDir, { recursive: true });
  }
  return (req, res, next) => {
    if (!res.locals) {
      res.locals = {};
    }
    if (req.method === "POST" && req.headers["content-type"] && req.headers["content-type"].startsWith("multipart/form-data")) {
      const contentType = req.headers["content-type"];
      const boundary = contentType?.split("; ")[1]?.replace("boundary=", "");
      if (!boundary) {
        res.statusCode = 400;
        return res.end("Boundary ausente no content-type");
      }
      const chunks = [];
      let fileSize = 0;
      const MAX_FILE_SIZE = options.maxFileSize || 50 * 1024 * 1024;
      req.on("data", (chunk) => {
        fileSize += chunk.length;
        if (fileSize > MAX_FILE_SIZE) {
          res.statusCode = 413;
          return res.end("Arquivo muito grande");
        }
        chunks.push(chunk);
      });
      req.on("end", () => {
        try {
          const buffer = Buffer.concat(chunks);
          const boundaryBytes = Buffer.from(`--${boundary}`);
          let startIndex = 0;
          let filesSaved = [];
          while ((startIndex = buffer.indexOf(boundaryBytes, startIndex)) !== -1) {
            startIndex += boundaryBytes.length;
            const endIndex = buffer.indexOf(boundaryBytes, startIndex);
            const part = buffer.slice(startIndex, endIndex !== -1 ? endIndex : buffer.length);
            const headerEndIndex = part.indexOf("\r\n\r\n");
            if (headerEndIndex === -1) break;
            const headers = part.slice(0, headerEndIndex).toString("utf8");
            const fileBuffer = part.slice(headerEndIndex + 4);
            const filenameMatch = headers.match(/filename="([^"]+)"/);
            if (filenameMatch) {
              const originalFilename = filenameMatch[1];
              const fileExtension = options.format || path.extname(originalFilename);
              let filename = originalFilename;
              filename += fileExtension;
              const filePath = path.join(uploadDir, filename);
              fs.writeFileSync(filePath, fileBuffer);
              filesSaved.push(filePath);
            }
            if (endIndex === -1) break;
          }
          req.files = filesSaved;
          res.locals.uploadedFilePaths = filesSaved;
          next();
        } catch (error) {
          console.error("Erro no upload:", error);
          res.statusCode = 500;
          res.end("Erro no upload");
        }
      });
      req.on("error", (err) => {
        console.error("Erro no upload:", err);
        res.statusCode = 500;
        res.end("Erro no upload");
      });
    } else {
      next();
    }
  };
};
var upload_default = uploadMiddleware;

// src/libserver.ts
var Server = class {
  middlewares;
  router;
  requestHandler;
  server;
  constructor() {
    this.middlewares = [];
    this.router = new Router_default();
    this.requestHandler = new RequestHandler_default(this.middlewares, this.router);
    this.server = http.createServer((req, res) => {
      const adaptedReq = req;
      const adaptedRes = res;
      this.requestHandler.handleRequest(adaptedReq, adaptedRes);
    });
  }
  use(middleware) {
    this.middlewares.push(middleware);
  }
  json() {
    return json_default;
  }
  upload(options) {
    return upload_default(options);
  }
  get(path2, ...middlewares) {
    this.router.get(path2, ...middlewares);
  }
  post(path2, ...middlewares) {
    this.router.post(path2, ...middlewares);
  }
  put(path2, ...middlewares) {
    this.router.put(path2, ...middlewares);
  }
  patch(path2, ...middlewares) {
    this.router.patch(path2, ...middlewares);
  }
  delete(path2, ...middlewares) {
    this.router.delete(path2, ...middlewares);
  }
  listen(port, cb) {
    this.server.listen(port, cb);
  }
};
var libserver_default = Server;
export {
  libserver_default as default
};
//# sourceMappingURL=libserver.js.map